<!DOCTYPE html>
<html lang="en">
<head>
<title>Real Time Movement Sync PoC</title>
<script type="text/javascript">
window.onload = function () {
    const NO_CHANGE = 0;
    const UP = 1
    const DOWN = 2
    const LEFT = 3
    const RIGHT = 4
    const STOP = 5

    const clientDelay = 100;
    const radius = 25;

    let conn;
    let positions = {};
    let pressedMap = {};
    let clientId = null;
    let pov_X = 250;
    let pov_Y = 250;
    let pov_direction = 0.0;
    const canvasHeight = 750;
    const canvasWidth = 750;

    if (window["WebSocket"]) {
        conn = new WebSocket("ws://" + document.location.host + "/ws");
        conn.onclose = function (evt) {
            console.log("Connection closed");
        };
        conn.onmessage = function (evt) {
            msg = JSON.parse(evt.data);
            console.log(msg);
            if (msg['UUID']) {
                const uuid = msg['UUID'];
                clientId = uuid;
                console.log("Received UUID from the server: " + uuid);
                draw();
            } else {
                for (const entry of msg['updates']) {
                    const uuid = entry['id'];
                    if (!positions[uuid]) positions[uuid] = [];
                    let queue = positions[uuid];
                    queue.push(entry);
                }
            }
        };
    } else {
        console.log("Browser does not support websockets");
    }

    let sendMsg = (msg) => {
        console.log(msg);
        msg = JSON.stringify(msg);
        conn.send(msg);
    }

    let handleKey = (e) => {
        const sourceKey = String.fromCharCode(e.keyCode).toLowerCase();
        if ((sourceKey === 'w' || sourceKey === 's') && e.type =='keyup') {
            //state.dropEntry('movements', characterUUID);
            lastSync = null;
            let cmd = {'id':clientId, 'direction':{'forward':STOP, 'angular':NO_CHANGE}};
            sendMsg(cmd)
        } else if ((sourceKey === 'w' || sourceKey === 's') && e.type =='keydown' && !pressedMap[e.keyCode]) {
            let direction = null;
            if (sourceKey == 'w') {
                direction = UP;
            } else if (sourceKey == 's') {
                direction = DOWN;
            }
            lastSync = new Date().getTime();
            let cmd = {'id':clientId, 'direction':{'forward':direction, 'angular':NO_CHANGE}};
            sendMsg(cmd);
        } else if ( (sourceKey === 'a' || sourceKey === 'd') && e.type =='keyup' ) {
            //state.dropEntry('torque', characterUUID);
            lastSync = null;
            let cmd = {'id':clientId, 'direction':{'forward':NO_CHANGE, 'angular':STOP}};
            sendMsg(cmd);
        } else if ((sourceKey === 'a' || sourceKey === 'd') && e.type =='keydown' && !pressedMap[e.keyCode]) {
            let direction = null;
            if (sourceKey == 'a') {
                direction = LEFT;
            } else if (sourceKey == 'd') {
                direction = RIGHT;
            }
            lastSync = new Date().getTime();
            let cmd = {'id':clientId, 'direction':{'forward':NO_CHANGE, 'angular':direction}};
            sendMsg(cmd);
        }
        pressedMap[e.keyCode] = e.type == 'keydown';
    }
    window.onkeydown = handleKey;
    window.onkeyup = handleKey;
    let interpolate = (realPositions) => {
        const interpolated = {};
        const now = new Date().getTime();
        const delayedNow = now - clientDelay;
        for (const _id in realPositions) {
            const queue = realPositions[_id];
            if (queue.length > 1) {
                if (queue[0]['time'] < delayedNow || !queue[0]['time']) queue.shift();
            }
            if (queue.length > 1) {
                const in1 = queue[0];
                const in2 = queue[1];
                if (!in2['time'] || !in1['time']) {
                    queue.shift();
                    const el = queue[0];
                    interpolated[el.id] = el;
                } else {
                    const delta = in2['time'] - in1['time'];
                    const diffX = in2['x'] - in1['x'];
                    const diffY = in2['y'] - in1['y'];
                    const diffD = in2['direction'] - in1['direction'];
                    const completion = (delayedNow - in1['time'])/ delta;
                    const xOffset = diffX * completion;
                    const yOffset = diffY * completion;
                    const dOffset = diffD * completion;
                    const interpolatedPos = {x: in2['x'] + xOffset,
                        y:in2['y'] + yOffset,
                        direction:in2['direction'] + dOffset ,
                        id:_id 
                    };
                    interpolated[_id] = interpolatedPos;
                }
            } else if (queue.length == 1) {
                const el = queue[0];
                interpolated[el.id] = el;
            } 
        }
        return interpolated;
    }

    draw = () => {
        const interpolatedPositions = interpolate(positions);
        
        if (interpolatedPositions[clientId]) {
            let pov = interpolatedPositions[clientId];
            pov_X = pov.x;
            pov_Y = pov.y;
            pov_direction = pov.direction;
            
        }
        cornerPov = leftTopCorner(pov_X, pov_Y, canvasWidth, canvasHeight);
        
        const canvas = document.getElementById("mainCanvas");

        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        for (let characterID in interpolatedPositions) {
            const pos = interpolatedPositions[characterID];
            if (pos === undefined) continue;
            const realX = pos.x - cornerPov.x;
            const realY = pos.y - cornerPov.y;
            let x = realX;
            let y = realY;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.stroke();
        }
        window.requestAnimationFrame(draw);
    }

    let leftTopCorner = (x, y, width, height) => {
        x = x - width/2;
        y = y - height/2;
        return {x:x, y:y};
    }

};
</script>
<style type="text/css">
html {
    overflow: hidden;
}
</style>
</head>
<body>
    <canvas id="mainCanvas" width="750" height="750"></canvas>
</body>
</html>
