<!DOCTYPE html>
<html lang="en">
<head>
<title>Real Time Movement Sync PoC</title>
<script type="text/javascript">
window.onload = function () {
    function guid() {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
        s4() + '-' + s4() + s4() + s4();
    }
    const NO_CHANGE = 0;
    const UP = 1
    const DOWN = 2
    const LEFT = 3
    const RIGHT = 4
    const STOP = 5

    let conn;
    let positions = {};
    const clientId = guid();
    let pov_X = 250;
    let pov_Y = 250;
    let pov_direction = 0.0;
    const canvasHeight = 750;
    const canvasWidth = 750;

    if (window["WebSocket"]) {
        conn = new WebSocket("ws://" + document.location.host + "/ws");
        conn.onclose = function (evt) {
            console.log("Connection closed");
        };
        conn.onmessage = function (evt) {
            let updates = evt.data;
            for (const entry of updates) {
                const uuid = entry['id'];
                if (!positions[uuid]) positions[uuid] = [];
                let queue = positions[uuid];
                queue.push(entry);
            }
        };
    } else {
        console.log("Browser does not support websockets");
    }

    let handleKey = (e) => {
        const sourceKey = String.fromCharCode(e.keyCode).toLowerCase();
        if ((sourceKey === 'w' || sourceKey === 's') && e.type =='keyup') {
            state.dropEntry('movements', this.characterUUID);
            this.lastSync = null;
            let cmd = {'id':clientId, 'direction':{'forward':STOP, 'angular':NO_CHANGE}};
            cmd = JSON.stringify(cmd);
            conn.send(cmd);
        } else if ((sourceKey === 'w' || sourceKey === 's') && e.type =='keydown' && !this.pressedMap[e.keyCode]) {
            let direction = null;
            if (sourceKey == 'w') {
                direction = UP;
            } else if (sourceKey == 's') {
                direction = DOWN;
            }
            this.lastSync = new Date().getTime();
            let cmd = {'id':clientId, 'direction':{'forward':direction, 'angular':NO_CHANGE}};
            cmd = JSON.stringify(cmd);
            conn.send(cmd);
        } else if ( (sourceKey === 'a' || sourceKey === 'd') && e.type =='keyup' ) {
            state.dropEntry('torque', this.characterUUID);
            this.lastSync = null;
            let cmd = {'id':clientId, 'direction':{'forward':NO_CHANGE, 'angular':STOP}};
            cmd = JSON.stringify(cmd);
            conn.send(cmd);
        } else if ((sourceKey === 'a' || sourceKey === 'd') && e.type =='keydown' && !this.pressedMap[e.keyCode]) {
            let direction = null;
            if (sourceKey == 'a') {
                direction = LEFT;
            } else if (sourceKey == 'd') {
                direction = RIGHT;
            }
            this.lastSync = new Date().getTime();
            let cmd = {'id':clientId, 'direction':{'forward':NO_CHANGE, 'angular':direction}};
            cmd = JSON.stringify(cmd);
            conn.send(cmd);
        }
        this.pressedMap[e.keyCode] = e.type == 'keydown';
    }
    window.onkeydown = handleKey;
    window.onkeyup = handleKey;
    let interpolate = (realPositions) => {
        const interpolated = {};
        const now = new Date().getTime();
        const delayedNow = now - clientDelay;
        for (const _id in realPositions) {
            const queue = realPositions[_id];
            if (queue.length > 1) {
                if (queue[0]['time'] < delayedNow || !queue[0]['time']) queue.shift();
            }
            if (queue.length > 1) {
                const in1 = queue[0];
                const in2 = queue[1];
                if (!in2['time'] || !in1['time']) {
                    queue.shift();
                    const el = queue[0];
                    interpolated[el.id] = el;
                } else {
                    const delta = in2['time'] - in1['time'];
                    const diffX = in2['x'] - in1['x'];
                    const diffY = in2['y'] - in1['y'];
                    const diffD = in2['direction'] - in1['direction'];
                    const completion = (delayedNow - in1['time'])/ delta;
                    const xOffset = diffX * completion;
                    const yOffset = diffY * completion;
                    const dOffset = diffD * completion;
                    const interpolatedPos = {x: in2['x'] + xOffset,
                        y:in2['y'] + yOffset,
                        direction:in2['direction'] + dOffset ,
                        id:_id 
                    };
                    interpolated[_id] = interpolatedPos;
                }
            } else if (queue.length == 1) {
                const el = queue[0];
                interpolated[el.id] = el;
            } 
        }
        return interpolated;
    }

    draw = () => {
        const positions = this.interpolate(positions);
        
        if (positions[clientId]) {
            let pov = positions[clientId];
            pov_X = pov.x;
            pov_Y = pov.y;
            pov_direction = pov.direction;
            
        }
        cornerPov = leftTopCorner(pov_X, pov_Y, canvasWidth, canvasHeight);
        
        const canvas = document.getElementById("mainCanvas");

        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        for (let characterID in positions) {
            const pos = positions[characterID];
            if (pos === undefined) continue;
            const realX = pos.x - cornerPov.x;
            const realY = pos.y - cornerPov.y;
            let x = realX;
            let y = realY;
            if (characterAsset) {
                const tx = x - 25;
                const ty = y - 25;
                let rotatedimg = this.rotateAndCache(characterAsset, pos.direction);
                ctx.drawImage(rotatedimg,  tx, ty);
            } else {
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.stroke();
            }
        }
        window.requestAnimationFrame(this.draw);
    }

    let leftTopCorner = (x, y, width, height) => {
        x = x - width/2;
        y = y - height/2;
        return {x:x, y:y};
    }

};
</script>
<style type="text/css">
html {
    overflow: hidden;
}
</style>
</head>
<body>
    <canvas id="mainCanvas" width="750" height="750"></canvas>
</body>
</html>
